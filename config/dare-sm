#!/usr/bin/env sh

CONFIGDIR=/etc/daring/subscriptions


PATH=/sbin:/bin:/usr/bin

PROG=$(basename $0)
RETVAL=0
SUBDIR=""

function printHelp {
   echo $* 1>&2
   echo "
  ${PROG} subscriptions [<search>]*
    List current subscriptions.

  ${PROG} subscribe <subscription>+
    Manual add subscription. Must be used with install.

  ${PROG} subscribe --dir <directory> [<selection>]*  [--dir <directory> [<selections>]* ]*
    Update and install subscription list

  ${PROG} install --dir <directory> [--dir <directory>]*
    If you have a seperate set of service directories from the subscribe directory.

  ${PROG} services [<search>]*
    List services

  ${PROG} update
    Update dare-sm

  ${PROG} <command> all
  ${PROG} <command> [<search>]*
  <command>
    install     : Run during first boot of instance
    update      : Upgrade the services
    start       : Start services
    stop        : Stop services
    restart     ; Restart services
    status      : Status of services
    unsubscribe : Remove a service from local configuration
    enable      : Temporary enable  a service
    disable     : Temporary disable a service
   " 1>&2
   exit 1
}
function abspath {
    if [[ -d "$1" ]]
    then
        pushd "$1" >/dev/null
        pwd
        popd >/dev/null
    elif [[ -e $1 ]]
    then
        pushd "$(dirname "$1")" >/dev/null
        echo "$(pwd)/$(basename "$1")"
        popd >/dev/null
    else
        echo "$1" does not exist! >&2
        return 127
    fi
}
function error {
    echo $*
    exit 128
}
function log {
    echo $*
}
function _getSettingFile {
    local file
    file=${CONFIGDIR}/$(basename ${1})
    if [ ! -d ${CONFIGDIR} ]
    then
        mkdir -p $CONFIGDIR || error "failed to create $CONFIGDIR"
    fi
    if [ ! -f ${file} ]
    then
        touch ${file}
    fi
    echo ${file}
}
function checkRoot {
    if [[ $( id -u) -ne "0" ]]
    then
        error "Must execute command as root"
        exit 128
    fi
}
function _mark {
    # PARAMETERS VALUE TAG [services pattern]
    local TAG
    local SERVICE
    export TAG=$1
    export VALUE=$2
    SERVICE=$(_getSettingFile ${3})

    if [ -s ${SERVICE} ]
    then
        perl -ni -e '
            if (! /^\s*$ENV{TAG}=.*$/) { print };
            if (eof) { print "$ENV{TAG}=$ENV{VALUE}\n"} ' ${SERVICE}
    else
        echo "${TAG}=${VALUE}" > ${SERVICE}
    fi
}
function _isMark {
    local TAG
    local VALUE
    local SERVICE
    TAG=$1
    VALUE=$2
    SERVICE=$(_getSettingFile $3)
    grep "${TAG}=${VALUE}" ${SERVICE}>/dev/null
    return $?
}
function _getMark {
    local TAG
    local SERVICE
    TAG=$1
    SERVICE=$(_getSettingFile $3)
    grep ${TAG} ${SERVICE} | cut -d= -f2
}

function _installSubscriptions {
    local DIR
    local SUB
    DIR=$1

    for SUB in $(ls -d ${DIR}/[0-9]* 2>/dev/null)
    do
        log "Installing service ${SUB}"
        _mark SCRIPT $(abspath ${SUB}) ${SUB} || error "Failed to install subscription to ${SUB}"
    done
}
function _descendDir() {
    local dir
    local dir2

    dir=$1

    for dir2 in $(ls -d ${dir}/* 2>/dev/null)
    do
        if [ -d "${dir2}" ]
        then
            _subscribeDir "${dir2}"
        fi
    done
}
function _subscribeDir() {
    local dir
    local dir2
    local list
    local RC

    dir=$1
    if [ -f ${dir}/subscriber ]
    then
        list=$(cd ${dir}; sh subscriber)
        RC=$?
        for dir2 in ${list}
        do
            if [ ${dir2} == '.' ]
            then
                _installSubscriptions ${dir}
                if [ "$RC" -eq "0" ]
                then
                    _descendDir ${dir}
                fi
            elif [ -d ${dir}/${dir2} ]
            then
                if [ -f ${dir}/${dir2}/subscriber ]
                then
                    _subscribeDir ${dir}/${dir2}
                else
                    _installSubscriptions ${dir}/${dir2}
                    _descendDir ${dir}/${dir2}
                fi
            fi
        done
    else
        _descendDir ${dir}
    fi
}
function subscribe {
    if [[ $1 != "--dir" ]]
    then
        printHelp
    else
        while [[ $# -gt 0 ]]
        do
            if [[ "$1" == "--dir" ]]
            then
                SUBDIR=$2
                shift
                shift
                if [[ ! -e ${SUBDIR}/subscriber ]]
                then
                    error "subscriber must exist in root directory $(abspath ${SUBDIR})"
                fi
                if [[ $# -eq 0 || $1 == "--dir" ]]
                then
                    _subscribeDir ${SUBDIR}
                fi
            else
                 _subscribeDir -e ${SUBDIR}/${1}
                shift
            fi
        done
    fi
}
function subscriptions() {
    local PATT
    local GREP
    PATT=$*
    if [[ "$PATT" == "all" ]]
    then
        GREP=cat
    else
        GREP="egrep $(echo $PATT | perl -pe 's/\s+[^\$]/|/g')"
    fi
    perl -ne '/SCRIPT=(.*)\/.*$/ && print "$1\n"' ${CONFIGDIR}/* | sort -u | $GREP
}
function services() {
    local PATT
    local GREP
    PATT=$*
    if [[ "$PATT" == "all" ]]
    then
        GREP=cat
    else
        GREP="egrep $(echo $PATT | perl -pe 's/\s+[^\$]/|/g')"
    fi
    perl -ne '/SCRIPT=(.*\/(.*))$/ && print "$2 $1\n"' ${CONFIGDIR}/* | sort -n | cut -d' ' -f2 | $GREP
}
function unsubscribe {
    local sub
    local file

    services $* | while read sub
    do
        log unsubscribe $sub
        file=$(_getSettingFile $sub)
        if [ -e ${file} ]
        then
            log removing service for ${sub}
            rm ${file} || log "Failed to remove service ${file}"
        fi
    done
}
function install {
    local RUN
    for RUN in $(services $*)
    do
        if _isMark INSTALLED TRUE ${RUN}
        then
            echo "Skipping ${RUN}, already installed"
        else
            echo "Install ${RUN}"
            if sh ${RUN} install
            then
                _mark INSTALLED TRUE ${RUN}
                _mark STATE INSTALLED ${RUN}
            fi
        fi
    done
}
function upgrade {
    local RUN
    for RUN in $(services $*)
    do
        if ! _isMark INSTALLED TRUE ${RUN}
        then
            install ${RUN}
        fi
        if _isMark INSTALLED TRUE ${RUN}
        then
            echo "upgrade ${RUN}"
            sh ${RUN} upgrade
        else
            echo "Skipping ${RUN}, not installed"
        fi
    done
}
function start {
    local RUN
    for RUN in $(services $*)
    do
        if _isMark INSTALLED TRUE ${RUN}
        then
            if _isMark STATE STARTED ${RUN}
            then
                echo "Skipping ${RUN}, already started"
            else
                echo "Starting ${RUN}"
                sh ${RUN} start
                RC=$?
                if [[ "$RC" == "0" ]]
                then
                    _mark STATE STARTED ${RUN}
                elif [[ "$RC" == "3" ]]
                then
                    _mark STATE INSTALLED_NO_START ${RUN}
                else
                    _mark STATE FAILED_START ${RUN}
                fi
            fi
        else
            echo "Skipping ${RUN}, not installed"
        fi
    done
}
function status {
    local RUN
    for RUN in $(services $*)
    do
        echo "${RUN}"
        sh ${RUN} status  | perl -pe 'print "     "'
    done
}
function state {
    local RUN
    for RUN in $(services $*)
    do
        echo "${RUN}"
        if _isMark INSTALLED TRUE ${RUN}
        then
            sh ${RUN} status | perl -pe 'print "     "'
            RC=$?
            if [[ ${RC} == "0" ]]
            then
                _mark STATUS STARTED ${RUN}
            elif [[ ${RC} == "200" ]]
            then
                _mark STATE INSTALLED_NO_START ${RUN}
            else
                _mark STATE STOPPED_${RC} ${RUN}
            fi
        fi
        sort $(_getSettingFile ${RUN}) | perl -pe 'print "     "'
    done
}
function stop {
    local RUN
    for RUN in $(services $*)
    do
        if _isMark INSTALLED TRUE ${RUN}
        then
            if sh ${RUN} stop
            then
                _mark STATE STOPPED ${RUN}
            fi
        else
            echo "Skipping ${RUN}, not installed"
        fi
    done
}
function restart {
    local RUN
    for RUN in $(services $*)
    do
        echo "Restarting ${RUN}"
        sh ${RUN} restart
    done
}

COMMAND=$1
shift
checkRoot
case "${COMMAND}" in
    subscribe)
        subscribe $*
        RETVAL=$?
	;;
	install)
        install $*
        RETVAL=$?
	;;
	unsubscribe)
        unsubscribe $*
        RETVAL=$?
	;;
	enable)
	    for SERVICE in $(services $*)
        do
	        _mark ENABLE TRUE ${SERVICE}
	    done
        RETVAL=$?
	;;
	disable)
	    for SERVICE in $(services $*)
        do
	        _mark ENABLE FALSE ${SERVICE}
	    done
        RETVAL=$?
	;;
	subscriptions)
	    subscriptions ${*:-all}
        RETVAL=$?
	;;
	services)
	    services ${*:-all}
        RETVAL=$?
	;;
	install)
        install $*
        RETVAL=$?
    ;;
	upgrade)
        upgrade $*
        RETVAL=$?
    ;;
    start)
        start $*
        RETVAL=$?
    ;;
	stop)
        stop $*
        RETVAL=$?

    ;;
	restart)
        restart $*
        RETVAL=$?
    ;;
	status)
        status ${*:-all}
        RETVAL=$?
    ;;
	state)
        state ${*:-all}
        RETVAL=$?
    ;;
    *)
        printHelp
        RETVAL=3
    ;;
esac
exit $RETVAL


# LSB RC (Return Codes) for all commands but status:
# 0	 - success
# 1  - generic or unspecified error
# 2  - invalid or excess argument(s)
# 3  - unimplemented feature (e.g. "reload")
# 4  - user had insufficient privileges
# 5  - program is not installed
# 6  - program is not configured
# 7  - program is not running
# 8--199  - reserved (8--99 LSB, 100--149 distrib, 150--199 appl)
#
# Note that starting an already running service, stopping
# or restarting a not-running service as well as the restart
# with force-reload (in case signaling is not supported) are
# considered a success.
#
# LSB RC for status command:
# 0 - service up and running
# 1 - service dead, but /var/run/  pid  file exists
# 2 - service dead, but /var/lock/ lock file exists
# 3 - service not running
# 4 - service status unknown :-(
# 5--199 reserved (5--99 LSB, 100--149 distro, 150--199 appl.)